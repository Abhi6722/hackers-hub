"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7835],{4137:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return c}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),h=p(n),c=o,m=h["".concat(s,".").concat(c)]||h[c]||d[c]||r;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function c(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},4037:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},assets:function(){return u},toc:function(){return d},default:function(){return c}});var a=n(7462),o=n(3366),r=(n(7294),n(4137)),i=["components"],l={title:"File Uploads with WebdriverIO",author:"Christian Bromann",authorURL:"https://twitter.com/bromann",authorImageURL:"https://s.gravatar.com/avatar/d98b16d7c93d15865f34a225dd4b1254?s=80"},s=void 0,p={permalink:"/blog/2019/06/25/file-upload",editUrl:"https://github.com/Abhi6722/hackers-hub/edit/main/website/blog/blog/2019-06-25-file-upload.md",source:"@site/blog/2019-06-25-file-upload.md",title:"File Uploads with WebdriverIO",description:"Testing an upload scenario in the browser is a rare but not uncommon case in the automation testing space. It is always important to evaluate the importance of such a test because in many situations you end up testing the browser more than your application. So always keep in mind how much additional functionality your frontend application puts on top of the default upload behavior of the browser. If for example most of the magic happens in the backend it makes much more sense to mimik an upload using a simple Node.js POST request using packages like request or axios.",date:"2019-06-25T00:00:00.000Z",formattedDate:"June 25, 2019",tags:[],readingTime:3.21,truncated:!1,authors:[{name:"Christian Bromann",url:"https://twitter.com/bromann",imageURL:"https://s.gravatar.com/avatar/d98b16d7c93d15865f34a225dd4b1254?s=80"}],prevItem:{title:"WebdriverIO V5 now also supports CucumberJS",permalink:"/blog/2019/07/11/cucumberjs-v5-released"},nextItem:{title:"Visual Regression for V5",permalink:"/blog/2019/05/18/visual-regression-for-v5"}},u={authorsImageUrls:[void 0]},d=[{value:"Find and expose file inputs",id:"find-and-expose-file-inputs",children:[],level:2},{value:"Uploading the file",id:"uploading-the-file",children:[],level:2}],h={toc:d};function c(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Testing an upload scenario in the browser is a rare but not uncommon case in the automation testing space. It is always important to evaluate the importance of such a test because in many situations you end up testing the browser more than your application. So always keep in mind how much additional functionality your frontend application puts on top of the default upload behavior of the browser. If for example most of the magic happens in the backend it makes much more sense to mimik an upload using a simple Node.js ",(0,r.kt)("inlineCode",{parentName:"p"},"POST")," request using packages like ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/request"},(0,r.kt)("inlineCode",{parentName:"a"},"request"))," or ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/axios"},(0,r.kt)("inlineCode",{parentName:"a"},"axios")),"."),(0,r.kt)("h2",{id:"find-and-expose-file-inputs"},"Find and expose file inputs"),(0,r.kt)("p",null,"Let's say our frontend app does a lot of things on top of just uploading a file (e.g. validation or some other frontend side manipulation of the file that is about to be uploaded). Now the first thing we should do is to find the input elements from type ",(0,r.kt)("inlineCode",{parentName:"p"},"file"),". Be aware that apps build in React, Angular or other frameworks often hide these elements as there are hard to style using pure CSS. Therefore they hide the elements and mimic the input with a ",(0,r.kt)("inlineCode",{parentName:"p"},"div")," or other more styleable HTML tags."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'// Two hidden input elements, 1 for single file upload 1 for multiple.\n<input class="upload-data-file-input hidden" type="file">\n<input class="upload-data-file-input-multiple hidden" type="file">\n')),(0,r.kt)("p",null,"In order to become capable to modify the value of this element we need to make it visible. The ",(0,r.kt)("a",{parentName:"p",href:"https://w3c.github.io/webdriver/#interactability"},"WebDriver spec")," defines input elements to be interactable in order to ",(0,r.kt)("a",{parentName:"p",href:"https://w3c.github.io/webdriver/#element-send-keys"},"change their value"),". So let's do that:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * The css class name \"upload-data-file-input hidden\" is just an example\n * and you can replace with your app.\n */\nconst fileUpload = $('.upload-data-file-input');\nbrowser.execute(\n    // assign style to elem in the browser\n    (el) => el.style.display = 'block',\n    // pass in element so we don't need to query it again in the browser\n    fileUpload\n);\nfileUpload.waitForDisplayed();\n")),(0,r.kt)("p",null,"With the ",(0,r.kt)("a",{parentName:"p",href:"https://webdriver.io/docs/api/browser/execute.html"},(0,r.kt)("inlineCode",{parentName:"a"},"execute"))," we can simply modify the element properties to either remove the ",(0,r.kt)("inlineCode",{parentName:"p"},"hidden")," class or give the element displayedness."),(0,r.kt)("h2",{id:"uploading-the-file"},"Uploading the file"),(0,r.kt)("p",null,"Unfortunately the mechanism to upload a file with a browser highly depends on your test setup. At the end of the day the browser needs to be able to access the file that you want tp upload. For the local scenario it is super simple. Since you run the browser on your local machine and the file that you want to upload also exists on your local machine, all you need to do is to set the value of the file path to the input element:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"/**\n * it is recommended to always use the absolute path of the file as it ensures\n * that it can be found by the browser.\n */\nconst path = require('path');\nconst filePath = path.join(__dirname, 'path/to/your/file');\nfileUpload.setValue(filePath);\n")),(0,r.kt)("p",null,"If you automate a browser that is running on a remote machine this approach won't work anymore because the file that is located locally (or wherever the tests are running) does not exist on the remote machine where the browser is running. For these scenarios the Selenium project created a ",(0,r.kt)("a",{parentName:"p",href:"https://webdriver.io/docs/api/chromium.html#file"},(0,r.kt)("inlineCode",{parentName:"a"},"file"))," that is currently only supported when running Chrome or using a Selenium Grid with the Selenium standalone server. The command expects the file payload to be passed in as base64 string. Since this is quite inconvenient to use WebdriverIO has implemented an ",(0,r.kt)("inlineCode",{parentName:"p"},"upload")," command that allows you to pass in just the file name and the framework takes care of parsing it properly. The upload example will now look like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"const path = require('path');\nconst filePath = path.join(__dirname, 'path/to/your/file');\n\nconst remoteFilePath = browser.uploadFile(filePath);\n$('.upload-data-file-input').setValue(remoteFilePath);\n")),(0,r.kt)("p",null,"Note that the remote file name is different from your local filename. Therefore you need to set the value based on the remote file name you get from the ",(0,r.kt)("inlineCode",{parentName:"p"},"uploadFile")," command."),(0,r.kt)("p",null,"That was it!!! Happy Uploading \ud83d\ude09\ud83d\ude4c\ud83c\udffb \u2764\ufe0f"))}c.isMDXComponent=!0}}]);