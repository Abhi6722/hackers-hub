"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5980],{4137:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=r,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2538:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(4137)),i=["components"],l={id:"selectors",title:"Selectors"},s=void 0,c={unversionedId:"selectors",id:"selectors",isDocsHomePage:!1,title:"Selectors",description:"The WebDriver Protocol provides several selector strategies to query an element. WebdriverIO simplifies them to keep selecting elements simple. Please note that even though the command to query elements is called $ and $$, they have nothing to do with jQuery or the Sizzle Selector Engine. The following selector types are supported:",source:"@site/docs/Selectors.md",sourceDirName:".",slug:"/selectors",permalink:"/docs/selectors",editUrl:"https://github.com/Abhi6722/hackers-hub/edit/main/website/docs/Selectors.md",tags:[],version:"current",frontMatter:{id:"selectors",title:"Selectors"},sidebar:"docs",previous:{title:"Driver Binaries",permalink:"/docs/driverbinaries"},next:{title:"Timeouts",permalink:"/docs/timeouts"}},p=[{value:"CSS Query Selector",id:"css-query-selector",children:[],level:2},{value:"Link Text",id:"link-text",children:[],level:2},{value:"Partial Link Text",id:"partial-link-text",children:[],level:2},{value:"Element with certain text",id:"element-with-certain-text",children:[],level:2},{value:"Tag Name",id:"tag-name",children:[],level:2},{value:"Name Attribute",id:"name-attribute",children:[],level:2},{value:"xPath",id:"xpath",children:[],level:2},{value:"ARIA - Role Attribute",id:"aria---role-attribute",children:[],level:2},{value:"ID Attribute",id:"id-attribute",children:[],level:2},{value:"JS Function",id:"js-function",children:[],level:2},{value:"Deep Selectors",id:"deep-selectors",children:[],level:2},{value:"Mobile Selectors",id:"mobile-selectors",children:[{value:"Android UiAutomator",id:"android-uiautomator",children:[],level:3},{value:"Android DataMatcher and ViewMatcher (Espresso only)",id:"android-datamatcher-and-viewmatcher-espresso-only",children:[],level:3},{value:"Android View Tag (Espresso only)",id:"android-view-tag-espresso-only",children:[],level:3},{value:"iOS UIAutomation",id:"ios-uiautomation",children:[],level:3},{value:"iOS XCUITest predicate strings and class chains",id:"ios-xcuitest-predicate-strings-and-class-chains",children:[],level:3},{value:"Accessibility ID",id:"accessibility-id",children:[],level:3},{value:"Class Name",id:"class-name",children:[],level:3}],level:2},{value:"Chain Selectors",id:"chain-selectors",children:[{value:"Appium Image Selector",id:"appium-image-selector",children:[],level:3}],level:2},{value:"React Selectors",id:"react-selectors",children:[{value:"Basic example",id:"basic-example",children:[],level:4},{value:"Filtering components",id:"filtering-components",children:[],level:4},{value:"Dealing with <code>React.Fragment</code>",id:"dealing-with-reactfragment",children:[],level:4}],level:2},{value:"Custom Selector Strategies",id:"custom-selector-strategies",children:[],level:2}],m={toc:p};function u(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://w3c.github.io/webdriver/"},"WebDriver Protocol")," provides several selector strategies to query an element. WebdriverIO simplifies them to keep selecting elements simple. Please note that even though the command to query elements is called ",(0,o.kt)("inlineCode",{parentName:"p"},"$")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"$$"),", they have nothing to do with jQuery or the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/jquery/sizzle"},"Sizzle Selector Engine"),". The following selector types are supported:"),(0,o.kt)("h2",{id:"css-query-selector"},"CSS Query Selector"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const elem = await $('h2.subheading a')\nelem.click()\n")),(0,o.kt)("h2",{id:"link-text"},"Link Text"),(0,o.kt)("p",null,"To get an anchor element with a specific text in it, query the text starting with an equals (",(0,o.kt)("inlineCode",{parentName:"p"},"="),") sign."),(0,o.kt)("p",null,"For example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<a href="https://webdriver.io">WebdriverIO</a>\n')),(0,o.kt)("p",null,"You can query this element by calling:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const link = await $('=WebdriverIO')\nconsole.log(await link.getText()) // outputs: \"WebdriverIO\"\nconsole.log(await link.getAttribute('href')) // outputs: \"https://webdriver.io\"\n")),(0,o.kt)("h2",{id:"partial-link-text"},"Partial Link Text"),(0,o.kt)("p",null,"To find a anchor element whose visible text partially matches your search value,\nquery it by using ",(0,o.kt)("inlineCode",{parentName:"p"},"*=")," in front of the query string (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"*=driver"),")."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<a href="https://webdriver.io">WebdriverIO</a>\n')),(0,o.kt)("p",null,"You can query this element by calling:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const link = await $('*=driver')\nconsole.log(await link.getText()) // outputs: \"WebdriverIO\"\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," You can't mix multiple selector strategies in one selector. Use multiple chained element queries to reach the same goal, e.g.:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const elem = await $('header h1*=Welcome') // doesn't work!!!\n// use instead\nconst elem = await $('header').$('*=driver')\n")),(0,o.kt)("h2",{id:"element-with-certain-text"},"Element with certain text"),(0,o.kt)("p",null,"The same technique can be applied to elements as well."),(0,o.kt)("p",null,'For example, here\'s a query for a level 1 heading with the text "Welcome to my Page":'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<h1 alt="welcome-to-my-page">Welcome to my Page</h1>\n')),(0,o.kt)("p",null,"You can query this element by calling:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const header = await $(\'h1=Welcome to my Page\')\nconsole.log(await header.getText()) // outputs: "Welcome to my Page"\nconsole.log(await header.getTagName()) // outputs: "h1"\n')),(0,o.kt)("p",null,"Or using query partial text:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const header = await $('h1*=Welcome')\nconsole.log(await header.getText()) // outputs: \"Welcome to my Page\"\n")),(0,o.kt)("p",null,"The same works for ",(0,o.kt)("inlineCode",{parentName:"p"},"id")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"class")," names:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<i class="someElem" id="elem">WebdriverIO is the best</i>\n')),(0,o.kt)("p",null,"You can query this element by calling:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const classNameAndText = await $('.someElem=WebdriverIO is the best')\nconsole.log(await classNameAndText.getText()) // outputs: \"WebdriverIO is the best\"\n\nconst idAndText = await $('#elem=WebdriverIO is the best')\nconsole.log(await idAndText.getText()) // outputs: \"WebdriverIO is the best\"\n\nconst classNameAndPartialText = await $('.someElem*=WebdriverIO')\nconsole.log(await classNameAndPartialText.getText()) // outputs: \"WebdriverIO is the best\"\n\nconst idAndPartialText = await $('#elem*=WebdriverIO')\nconsole.log(await idAndPartialText.getText()) // outputs: \"WebdriverIO is the best\"\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," You can't mix multiple selector strategies in one selector. Use multiple chained element queries to reach the same goal, e.g.:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const elem = await $('header h1*=Welcome') // doesn't work!!!\n// use instead\nconst elem = await $('header').$('h1*=Welcome')\n")),(0,o.kt)("h2",{id:"tag-name"},"Tag Name"),(0,o.kt)("p",null,"To query an element with a specific tag name, use ",(0,o.kt)("inlineCode",{parentName:"p"},"<tag>")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"<tag />"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<my-element>WebdriverIO is the best</my-element>\n")),(0,o.kt)("p",null,"You can query this element by calling:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const classNameAndText = await $('<my-element />')\nconsole.log(await classNameAndText.getText()) // outputs: \"WebdriverIO is the best\"\n")),(0,o.kt)("h2",{id:"name-attribute"},"Name Attribute"),(0,o.kt)("p",null,"For querying elements with a specific name attribute you can either use a normal CSS3 selector or the provided name strategy from the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/SeleniumHQ/selenium/wiki/JsonWireProtocol"},"JSONWireProtocol")," by passing something like ",'[name="some-name"]'," as selector parameter:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<input name="username" value="foobar" />\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const classNameAndText = await $(\'[name="username"]\')\nconsole.log(await classNameAndText.getValue()) // outputs: "foobar"\n')),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," This selector strategy it deprecated and only works in old browser that are run by the JSONWireProtocol protocol or by using Appium."),(0,o.kt)("h2",{id:"xpath"},"xPath"),(0,o.kt)("p",null,"It is also possible to query elements via a specific ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/XPath"},"xPath"),"."),(0,o.kt)("p",null,"An xPath selector has a format like ",(0,o.kt)("inlineCode",{parentName:"p"},"//body/div[6]/div[1]/span[1]"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<html>\n    <body>\n        <p>foobar</p>\n        <p>barfoo</p>\n    </body>\n</html>\n")),(0,o.kt)("p",null,"You can query the second paragraph by calling:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const paragraph = await $('//body/p[2]')\nconsole.log(await paragraph.getText()) // outputs: \"barfoo\"\n")),(0,o.kt)("p",null,"You can use xPath to also traverse up and down the DOM tree:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const parent = await paragraph.$('..')\nconsole.log(await parent.getTagName()) // outputs: \"body\"\n")),(0,o.kt)("h2",{id:"aria---role-attribute"},"ARIA - Role Attribute"),(0,o.kt)("p",null,"For querying elements based on ",(0,o.kt)("a",{parentName:"p",href:"https://www.w3.org/TR/html-aria/#docconformance"},"ARIA roles"),", you can directly specify role of the element like ",(0,o.kt)("inlineCode",{parentName:"p"},"[role=button]")," as selector parameter:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<button>Click me</button>\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const button = await $('[role=button]')\n\n// perform click on button element\nconsole.log(await button.click())\n")),(0,o.kt)("h2",{id:"id-attribute"},"ID Attribute"),(0,o.kt)("p",null,'Locator strategy "id" is not supported in WebDriver protocol, one should use either CSS or xPath selector strategies instead to find elements using ID.'),(0,o.kt)("p",null,"However some drivers (e.g. ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/YOU-i-Labs/appium-youiengine-driver#selector-strategies"},"Appium You.i Engine Driver"),") might still ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/YOU-i-Labs/appium-youiengine-driver#selector-strategies"},"support")," this selector."),(0,o.kt)("p",null,"Current supported selector syntaxes for ID are:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"//css locator\nconst button = await $('#someid')\n//xpath locator\nconst button = await $('//*[@id=\"someid\"'])\n//id strategy \n// Note: works only in Appium or similar frameworks which supports locator strategy \"ID\"\nconst button = await $('id=resource-id/iosname')\n")),(0,o.kt)("h2",{id:"js-function"},"JS Function"),(0,o.kt)("p",null,"You can also use JavaScript functions to fetch elements using web native APIs. Of course, you can only do this inside a web context (e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"browser"),", or web context in mobile)."),(0,o.kt)("p",null,"Given the following HTML structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<html>\n    <body>\n        <p id="elem">foobar</p>\n        <p>barfoo</p>\n    </body>\n</html>\n')),(0,o.kt)("p",null,"You can query the sibling element of ",(0,o.kt)("inlineCode",{parentName:"p"},"#elem")," as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const elem = await $('#elem') // or $(() => document.getElementById('elem'))\nawait elem.$(function () { return this.nextSibling.nextSibling }) // (first sibling is #text with value (\"\u21b5\"))\n")),(0,o.kt)("h2",{id:"deep-selectors"},"Deep Selectors"),(0,o.kt)("p",null,"Many frontend applications heavily rely on elements with ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_shadow_DOM"},"shadow DOM"),". It is technically impossible to query elements within the shadow DOM without workarounds. The ",(0,o.kt)("a",{parentName:"p",href:"https://webdriver.io/docs/api/element/shadow$"},(0,o.kt)("inlineCode",{parentName:"a"},"shadow$"))," and ",(0,o.kt)("a",{parentName:"p",href:"https://webdriver.io/docs/api/element/shadow$$"},(0,o.kt)("inlineCode",{parentName:"a"},"shadow$$"))," have been such workarounds that had their ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Georgegriff/query-selector-shadow-dom#how-is-this-different-to-shadow"},"limitations"),". With the deep selector you can now query all elements within any shadow DOM using the common query command."),(0,o.kt)("p",null,"Given we have an application with the following structure:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/Georgegriff/query-selector-shadow-dom/raw/main/Chrome-example.png",alt:"Chrome Example",title:"Chrome Example"})),(0,o.kt)("p",null,"With this selector you can query the ",(0,o.kt)("inlineCode",{parentName:"p"},"<button />")," element that is nested within another shadow DOM, e.g.:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const button = await $('>>>.dropdown-item:not([hidden])')\nconsole.log(await button.getText()) // outputs: \"Open downloads folder\"\n")),(0,o.kt)("h2",{id:"mobile-selectors"},"Mobile Selectors"),(0,o.kt)("p",null,"For hybrid mobile testing, it's important that the automation server is in the correct ",(0,o.kt)("em",{parentName:"p"},"context")," before executing commands. For automating gestures, the driver ideally should be set to native context. But to select elements from the DOM, the driver will need to be set to the platform's webview context. Only ",(0,o.kt)("em",{parentName:"p"},"then")," can the methods mentioned above can be used."),(0,o.kt)("p",null,"For native mobile testing, there is no switching between contexts, as you have to use mobile strategies and use the underlying device automation technology directly. This is especially useful when a test needs some fine-grained control over finding elements."),(0,o.kt)("h3",{id:"android-uiautomator"},"Android UiAutomator"),(0,o.kt)("p",null,"Android\u2019s UI Automator framework provides a number of ways to find elements. You can use the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.android.com/tools/testing-support-library/index.html#uia-apis"},"UI Automator API"),", in particular the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/android/support/test/uiautomator/UiSelector.html"},"UiSelector class")," to locate elements. In Appium you send the Java code, as a string, to the server, which executes it in the application\u2019s environment, returning the element or elements."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const selector = \'new UiSelector().text("Cancel").className("android.widget.Button")\'\nconst button = await $(`android=${selector}`)\nawait button.click()\n')),(0,o.kt)("h3",{id:"android-datamatcher-and-viewmatcher-espresso-only"},"Android DataMatcher and ViewMatcher (Espresso only)"),(0,o.kt)("p",null,"Android's DataMatcher strategy provides a way to find elements by ",(0,o.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/android/support/test/espresso/DataInteraction"},"Data Matcher")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const menuItem = await $({\n  "name": "hasEntry",\n  "args": ["title", "ViewTitle"]\n})\nawait menuItem.click()\n')),(0,o.kt)("p",null,"And similarly ",(0,o.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/android/support/test/espresso/ViewInteraction"},"View Matcher")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'const menuItem = await $({\n  "name": "hasEntry",\n  "args": ["title", "ViewTitle"],\n  "class": "androidx.test.espresso.matcher.ViewMatchers"\n})\nawait menuItem.click()\n')),(0,o.kt)("h3",{id:"android-view-tag-espresso-only"},"Android View Tag (Espresso only)"),(0,o.kt)("p",null,"The view tag strategy provides a convenient way to find elements by their ",(0,o.kt)("a",{parentName:"p",href:"https://developer.android.com/reference/android/support/test/espresso/matcher/ViewMatchers.html#withTagValue%28org.hamcrest.Matcher%3Cjava.lang.Object%3E%29"},"tag"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const elem = await $('-android viewtag:tag_identifier')\nawait elem.click()\n")),(0,o.kt)("h3",{id:"ios-uiautomation"},"iOS UIAutomation"),(0,o.kt)("p",null,"When automating an iOS application, Apple\u2019s ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/library/prerelease/tvos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/UIAutomation.html"},"UI Automation framework")," can be used to find elements."),(0,o.kt)("p",null,"This JavaScript ",(0,o.kt)("a",{parentName:"p",href:"https://developer.apple.com/library/ios/documentation/DeveloperTools/Reference/UIAutomationRef/index.html#//apple_ref/doc/uid/TP40009771"},"API")," has methods to access to the view and everything on it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const selector = 'UIATarget.localTarget().frontMostApp().mainWindow().buttons()[0]'\nconst button = await $(`ios=${selector}`)\nawait button.click()\n")),(0,o.kt)("p",null,"You can also use predicate searching within iOS UI Automation in Appium to refine element selection even further. See ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/ios/ios-predicate.md"},"here")," for details."),(0,o.kt)("h3",{id:"ios-xcuitest-predicate-strings-and-class-chains"},"iOS XCUITest predicate strings and class chains"),(0,o.kt)("p",null,"With iOS 10 and above (using the ",(0,o.kt)("inlineCode",{parentName:"p"},"XCUITest")," driver), you can use ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/WebDriverAgent/wiki/Predicate-Queries-Construction-Rules"},"predicate strings"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const selector = `type == 'XCUIElementTypeSwitch' && name CONTAINS 'Allow'`\nconst switch = await $(`-ios predicate string:${selector}`)\nawait switch.click()\n")),(0,o.kt)("p",null,"And ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/WebDriverAgent/wiki/Class-Chain-Queries-Construction-Rules"},"class chains"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const selector = '**/XCUIElementTypeCell[`name BEGINSWITH \"D\"`]/**/XCUIElementTypeButton'\nconst button = await $(`-ios class chain:${selector}`)\nawait button.click()\n")),(0,o.kt)("h3",{id:"accessibility-id"},"Accessibility ID"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"accessibility id")," locator strategy is designed to read a unique identifier for a UI element. This has the benefit of not changing during localization or any other process that might change text. In addition, it can be an aid in creating cross-platform tests, if elements that are functionally the same have the same accessibility id."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For iOS this is the ",(0,o.kt)("inlineCode",{parentName:"li"},"accessibility identifier")," laid out by Apple ",(0,o.kt)("a",{parentName:"li",href:"https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIAccessibilityIdentification_Protocol/index.html"},"here"),"."),(0,o.kt)("li",{parentName:"ul"},"For Android the ",(0,o.kt)("inlineCode",{parentName:"li"},"accessibility id")," maps to the ",(0,o.kt)("inlineCode",{parentName:"li"},"content-description")," for the element, as described ",(0,o.kt)("a",{parentName:"li",href:"https://developer.android.com/training/accessibility/accessible-app.html"},"here"),".")),(0,o.kt)("p",null,"For both platforms, getting an element (or multiple elements) by their ",(0,o.kt)("inlineCode",{parentName:"p"},"accessibility id")," is usually the best method. It is also the preferred way over the deprecated ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," strategy."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const elem = await $('~my_accessibility_identifier')\nawait elem.click()\n")),(0,o.kt)("h3",{id:"class-name"},"Class Name"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"class name")," strategy is a ",(0,o.kt)("inlineCode",{parentName:"p"},"string")," representing a UI element on the current view."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For iOS it is the full name of a ",(0,o.kt)("a",{parentName:"li",href:"https://developer.apple.com/library/prerelease/tvos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/UIAutomation.html"},"UIAutomation class"),", and will begin with ",(0,o.kt)("inlineCode",{parentName:"li"},"UIA-"),", such as ",(0,o.kt)("inlineCode",{parentName:"li"},"UIATextField")," for a text field. A full reference can be found ",(0,o.kt)("a",{parentName:"li",href:"https://developer.apple.com/library/ios/navigation/#section=Frameworks&topic=UIAutomation"},"here"),"."),(0,o.kt)("li",{parentName:"ul"},"For Android it is the fully qualified name of a ",(0,o.kt)("a",{parentName:"li",href:"https://developer.android.com/tools/testing-support-library/index.html#UIAutomator"},"UI Automator")," ",(0,o.kt)("a",{parentName:"li",href:"https://developer.android.com/reference/android/widget/package-summary.html"},"class"),", such ",(0,o.kt)("inlineCode",{parentName:"li"},"android.widget.EditText")," for a text field. A full reference can be found ",(0,o.kt)("a",{parentName:"li",href:"https://developer.android.com/reference/android/widget/package-summary.html"},"here"),"."),(0,o.kt)("li",{parentName:"ul"},"For Youi.tv it is the full name of a Youi.tv class, and will being with ",(0,o.kt)("inlineCode",{parentName:"li"},"CYI-"),", such as ",(0,o.kt)("inlineCode",{parentName:"li"},"CYIPushButtonView")," for a push button element. A full reference can be found at ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/YOU-i-Labs/appium-youiengine-driver"},"You.i Engine Driver's GitHub page"))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// iOS example\nawait $('UIATextField').click()\n// Android example\nawait $('android.widget.DatePicker').click()\n// Youi.tv example\nawait $('CYIPushButtonView').click()\n")),(0,o.kt)("h2",{id:"chain-selectors"},"Chain Selectors"),(0,o.kt)("p",null,"If you want to be more specific in your query, you can chain selectors until you've found the right\nelement. If you call ",(0,o.kt)("inlineCode",{parentName:"p"},"element")," before your actual command, WebdriverIO starts the query from that element."),(0,o.kt)("p",null,"For example, if you have a DOM structure like:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<div class="row">\n  <div class="entry">\n    <label>Product A</label>\n    <button>Add to cart</button>\n    <button>More Information</button>\n  </div>\n  <div class="entry">\n    <label>Product B</label>\n    <button>Add to cart</button>\n    <button>More Information</button>\n  </div>\n  <div class="entry">\n    <label>Product C</label>\n    <button>Add to cart</button>\n    <button>More Information</button>\n  </div>\n</div>\n')),(0,o.kt)("p",null,"And you want to add product B to the cart, it would be difficult to do that just by using the CSS selector."),(0,o.kt)("p",null,"With selector chaining, it's way easier. Simply narrow down the desired element step by step:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"await $('.row .entry:nth-child(2)').$('button*=Add').click()\n")),(0,o.kt)("h3",{id:"appium-image-selector"},"Appium Image Selector"),(0,o.kt)("p",null,"Using the  ",(0,o.kt)("inlineCode",{parentName:"p"},"-image")," locator strategy, it is possible to send an Appium an image file representing an element you want to access."),(0,o.kt)("p",null,"Supported file formats ",(0,o.kt)("inlineCode",{parentName:"p"},"jpg,png,gif,bmp,svg")),(0,o.kt)("p",null,"Full reference can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/image-elements.md"},"here")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const elem = await $('./file/path/of/image/test.jpg')\nawait elem.click()\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": The way how Appium works with this selector is that it will internally make a (app)screenshot and use the provided image selector\nto verify if the element can be found in that (app)screenshot."),(0,o.kt)("p",null,"Be aware of the fact that Appium might resize the taken (app)screenshot to make it match the CSS-size of your (app)screen (this will happen\non iPhones but also on Mac machines with a Retina display because the DPR is bigger than 1). This will result in not finding a match because\nthe provided image selector might have been taken from the original screenshot.\nYou can fix this by updating the Appium Server settings, see the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/appium/appium/blob/master/docs/en/advanced-concepts/image-elements.md#related-settings"},"Appium docs"),"\nfor the settings and ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/webdriverio/webdriverio/issues/6097#issuecomment-726675579"},"this comment")," on a detailed explanation."),(0,o.kt)("h2",{id:"react-selectors"},"React Selectors"),(0,o.kt)("p",null,"WebdriverIO provides a way to select React components based on the component name. To do this, you have a choice of two commands: ",(0,o.kt)("inlineCode",{parentName:"p"},"react$")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"react$$"),"."),(0,o.kt)("p",null,"These commands allow you to select components off the ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/faq-internals.html"},"React VirtualDOM")," and return either a single WebdriverIO Element or an array of elements (depending on which function is used)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note"),": The commands ",(0,o.kt)("inlineCode",{parentName:"p"},"react$")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"react$$")," are similar in functionality, except that ",(0,o.kt)("inlineCode",{parentName:"p"},"react$$")," will return ",(0,o.kt)("em",{parentName:"p"},"all")," matching instances as an array of WebdriverIO elements, and ",(0,o.kt)("inlineCode",{parentName:"p"},"react$")," will return the first found instance."),(0,o.kt)("h4",{id:"basic-example"},"Basic example"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"// index.jsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nfunction MyComponent() {\n    return (\n        <div>\n            MyComponent\n        </div>\n    )\n}\n\nfunction App() {\n    return (<MyComponent />)\n}\n\nReactDOM.render(<App />, document.querySelector('#root'))\n")),(0,o.kt)("p",null,"In the above code there is a simple ",(0,o.kt)("inlineCode",{parentName:"p"},"MyComponent")," instance inside the application, which React is rendering inside a HTML element with ",(0,o.kt)("inlineCode",{parentName:"p"},'id="root"'),"."),(0,o.kt)("p",null,"With the ",(0,o.kt)("inlineCode",{parentName:"p"},"browser.react$")," command, you can select an instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"MyComponent"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const myCmp = await browser.react$('MyComponent')\n")),(0,o.kt)("p",null,"Now that you have the WebdriverIO element stored in ",(0,o.kt)("inlineCode",{parentName:"p"},"myCmp")," variable, you can execute element commands against it."),(0,o.kt)("h4",{id:"filtering-components"},"Filtering components"),(0,o.kt)("p",null,"The library that WebdriverIO uses internally allows to filter your selection by props and/or state of the component. To do so, you need to pass a second argument for props and/or a third argument for state to the browser command."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"// index.jsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nfunction MyComponent(props) {\n    return (\n        <div>\n            Hello { props.name || 'World' }!\n        </div>\n    )\n}\n\nfunction App() {\n    return (\n        <div>\n            <MyComponent name=\"WebdriverIO\" />\n            <MyComponent />\n        </div>\n    )\n}\n\nReactDOM.render(<App />, document.querySelector('#root'))\n")),(0,o.kt)("p",null,"If you want to select the instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"MyComponent")," that has a prop ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," as ",(0,o.kt)("inlineCode",{parentName:"p"},"WebdriverIO"),", you can execute the command like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const myCmp = await browser.react$('MyComponent', {\n    props: { name: 'WebdriverIO' }\n})\n")),(0,o.kt)("p",null,"If you wanted to filter our selection by state, the ",(0,o.kt)("inlineCode",{parentName:"p"},"browser")," command would looks something like so:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const myCmp = await browser.react$('MyComponent', {\n    state: { myState: 'some value' }\n})\n")),(0,o.kt)("h4",{id:"dealing-with-reactfragment"},"Dealing with ",(0,o.kt)("inlineCode",{parentName:"h4"},"React.Fragment")),(0,o.kt)("p",null,"When using the ",(0,o.kt)("inlineCode",{parentName:"p"},"react$")," command to select React ",(0,o.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/fragments.html"},"fragments"),", WebdriverIO will return the first child of that component as the component's node. If you use ",(0,o.kt)("inlineCode",{parentName:"p"},"react$$"),", you will receive an array containing all the HTML nodes inside the fragments that match the selector."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"// index.jsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nfunction MyComponent() {\n    return (\n        <React.Fragment>\n            <div>\n                MyComponent\n            </div>\n            <div>\n                MyComponent\n            </div>\n        </React.Fragment>\n    )\n}\n\nfunction App() {\n    return (<MyComponent />)\n}\n\nReactDOM.render(<App />, document.querySelector('#root'))\n")),(0,o.kt)("p",null,"Given the above example, this is how the commands would work:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"await browser.react$('MyComponent') // returns the WebdriverIO Element for the first <div />\nawait browser.react$$('MyComponent') // returns the WebdriverIO Elements for the array [<div />, <div />]\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," If you have multiple instances of ",(0,o.kt)("inlineCode",{parentName:"p"},"MyComponent")," and you use ",(0,o.kt)("inlineCode",{parentName:"p"},"react$$")," to select these fragment components, you will be returned an one-dimensional array of all the nodes. In other words, if you have 3 ",(0,o.kt)("inlineCode",{parentName:"p"},"<MyComponent />")," instances, you will be returned an array with six WebdriverIO elements."),(0,o.kt)("h2",{id:"custom-selector-strategies"},"Custom Selector Strategies"),(0,o.kt)("p",null,"If your app requires a specific way to fetch elements you can define yourself a custom selector strategy that you can use with ",(0,o.kt)("inlineCode",{parentName:"p"},"custom$")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"custom$$"),". For that register your strategy once in the beginning of the test:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"browser.addLocatorStrategy('myCustomStrategy', (selector, root) => {\n    /**\n     * scope should be document if called on browser object\n     * and `root` if called on an element object\n     */\n    const scope = root ? root : document\n    return scope.querySelectorAll(selector)\n})\n")),(0,o.kt)("p",null,"Given the following HTML snippet:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},'<div class="foobar" id="first">\n    <div class="foobar" id="second">\n        barfoo\n    </div>\n</div>\n')),(0,o.kt)("p",null,"Then use it by calling:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const elem = await browser.custom$('myCustomStrategy', '.foobar')\nconsole.log(await elem.getAttribute('id')) // returns \"first\"\nconst nestedElem = await elem.custom$('myCustomStrategy', '.foobar')\nconsole.log(await elem.getAttribute('id')) // returns \"second\"\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Note:")," this only works in an web environment in which the ",(0,o.kt)("a",{parentName:"p",href:"/docs/api/browser/execute"},(0,o.kt)("inlineCode",{parentName:"a"},"execute"))," command can be run."))}u.isMDXComponent=!0}}]);