"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[1033],{4137:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),h=p(n),d=a,m=h["".concat(l,".").concat(d)]||h[d]||c[d]||r;return n?o.createElement(m,s(s({ref:t},u),{},{components:n})):o.createElement(m,s({ref:t},u))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var p=2;p<r;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},8412:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return p},assets:function(){return u},toc:function(){return c},default:function(){return d}});var o=n(7462),a=n(3366),r=(n(7294),n(4137)),s=["components"],i={title:"Shadow DOM Support & reusable component objects",author:"John Robinson",authorURL:"https://www.github.com/jrobinson01",authorImageURL:"https://avatars0.githubusercontent.com/u/1584296?s=460&v=4"},l=void 0,p={permalink:"/blog/2019/02/22/shadow-dom-support",editUrl:"https://github.com/Abhi6722/hackers-hub/edit/main/website/blog/blog/2019-02-22-shadow-dom-support.md",source:"@site/blog/2019-02-22-shadow-dom-support.md",title:"Shadow DOM Support & reusable component objects",description:"Shadow DOM is one of the key browser features that make up web components. Web components are a really great way to build reusable elements, and are able to scale all the way up to complete web applications. Style encapsulation, the feature that gives shadow DOM it's power, has been a bit of a pain when it comes to E2E or UI testing. Things just got a little easier though, as WebdriverIO v5.5.0 introduced built-in support for shadow DOM via two new commands, shadow$ and shadow$$. Let's dig into what they're all about.",date:"2019-02-22T00:00:00.000Z",formattedDate:"February 22, 2019",tags:[],readingTime:6.275,truncated:!1,authors:[{name:"John Robinson",url:"https://www.github.com/jrobinson01",imageURL:"https://avatars0.githubusercontent.com/u/1584296?s=460&v=4"}],prevItem:{title:"React Selectors",permalink:"/blog/2019/04/03/react-selectors"},nextItem:{title:"WebdriverIO v5 Released",permalink:"/blog/2018/12/19/webdriverio-v5-released"}},u={authorsImageUrls:[void 0]},c=[{value:"History",id:"history",children:[],level:2},{value:"The <code>shadow$</code> and <code>shadow$$</code> Commands",id:"the-shadow-and-shadow-commands",children:[],level:2},{value:"Page Objects",id:"page-objects",children:[],level:2},{value:"Component Objects",id:"component-objects",children:[],level:2},{value:"Future",id:"future",children:[],level:2},{value:"Browser Support",id:"browser-support",children:[],level:2}],h={toc:c};function d(e){var t=e.components,n=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,o.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Shadow DOM is one of the key browser features that make up web components. Web components are a really great way to build reusable elements, and are able to scale all the way up to complete web applications. Style encapsulation, the feature that gives shadow DOM it's power, has been a bit of a pain when it comes to E2E or UI testing. Things just got a little easier though, as WebdriverIO v5.5.0 introduced built-in support for shadow DOM via two new commands, ",(0,r.kt)("a",{parentName:"p",href:"https://webdriver.io/docs/api/element/shadow$.html"},(0,r.kt)("inlineCode",{parentName:"a"},"shadow$"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://webdriver.io/docs/api/element/shadow$$.html"},(0,r.kt)("inlineCode",{parentName:"a"},"shadow$$")),". Let's dig into what they're all about."),(0,r.kt)("h2",{id:"history"},"History"),(0,r.kt)("p",null,"With v0 of the shadow DOM spec, came the ",(0,r.kt)("inlineCode",{parentName:"p"},"/deep/")," selector. This special selector made it possible to query inside an element's ",(0,r.kt)("inlineCode",{parentName:"p"},"shadowRoot"),". Here we're querying for a button that is inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"my-element")," custom element's ",(0,r.kt)("inlineCode",{parentName:"p"},"shadowRoot"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"$('body my-element /deep/ button');\n")),(0,r.kt)("p",null,"The /deep/ selector was ",(0,r.kt)("a",{parentName:"p",href:"https://developers.google.com/web/updates/2017/10/remove-shadow-piercing"},"short lived"),", and is ",(0,r.kt)("a",{parentName:"p",href:"https://tabatkins.github.io/specs/css-shadow-parts/"},"rumored to be replaced")," some day."),(0,r.kt)("p",null,"With /deep/ being deprecated and subsequently removed, developers found other ways to get at their shadow elements. The typical approach was to use custom commands in WebdriverIO. These commands used the ",(0,r.kt)("inlineCode",{parentName:"p"},"execute")," command to string together querySelector and shadowRoot.querySelector calls in order to find elements. This generally worked such that, instead of a basic string query, queries were put into arrays. Each string in the array represented a shadow boundary. Using these commands looked something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const myButton = browser.shadowDomElement(['body my-element', 'button']);\n")),(0,r.kt)("p",null,"The downside of both the ",(0,r.kt)("inlineCode",{parentName:"p"},"/deep/")," selector and the javascript approach was that in order to find an element, the query always needed to start at the document level. This made tests a little unwieldy and hard to maintain. Code like this was not uncommon:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"it('submits the form', ()=> {\n  const myInput = browser.shadowDomElement(BASE_SELECTOR.concat(['my-deeply-nested-element', 'input']));\n  const myButton = browser.shadowDomElement(BASE_SELECTOR.concat(['my-deeply-nested-element', 'button']));\n  myInput.setValue('test');\n  myButton.click();\n});\n")),(0,r.kt)("h2",{id:"the-shadow-and-shadow-commands"},"The ",(0,r.kt)("inlineCode",{parentName:"h2"},"shadow$")," and ",(0,r.kt)("inlineCode",{parentName:"h2"},"shadow$$")," Commands"),(0,r.kt)("p",null,"These commands take advantage of the ",(0,r.kt)("inlineCode",{parentName:"p"},"$")," command in WebdriverIO v5's ability to use a function selector. They work just like the existing ",(0,r.kt)("a",{parentName:"p",href:"https://webdriver.io/docs/api/element/$.html"},(0,r.kt)("inlineCode",{parentName:"a"},"$"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://webdriver.io/docs/api/element/$$.html"},(0,r.kt)("inlineCode",{parentName:"a"},"$$"))," commands in that you call it on an element, but instead of querying an element's light DOM, they query an element's shadow DOM (they fall back to querying light dom if for whatever reason, you're not using any polyfills)."),(0,r.kt)("p",null,"Since they're element commands, it's no longer required to start at the root document when building your queries. Once you have an element, calling ",(0,r.kt)("inlineCode",{parentName:"p"},"element.shadow$('selector')")," queries inside that element's shadowRoot for the element that matches the given selector. From any element, you can chain ",(0,r.kt)("inlineCode",{parentName:"p"},"$")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"shadow$")," commands as deeply as needed."),(0,r.kt)("h2",{id:"page-objects"},"Page Objects"),(0,r.kt)("p",null,"Like their counterparts, ",(0,r.kt)("inlineCode",{parentName:"p"},"$")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"$$"),", the shadow commands make page objects a breeze to write, read and maintain. Let's assume we're working with a page that looks something like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-html"},"<body>\n  <my-app>\n    <app-login></app-login>\n  </my-app>\n</body>\n")),(0,r.kt)("p",null,"This uses two custom elements, ",(0,r.kt)("inlineCode",{parentName:"p"},"my-app")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"app-login"),". We can see that ",(0,r.kt)("inlineCode",{parentName:"p"},"my-app")," is in the ",(0,r.kt)("inlineCode",{parentName:"p"},"body"),"'s light DOM, and inside it's light DOM is an ",(0,r.kt)("inlineCode",{parentName:"p"},"app-login")," element. An example of a page object to interact with this page might look like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"class LoginPage {\n\n  open() {\n    browser.url('/login');\n  }\n\n  get app() {\n    // my-app lives in the document's light DOM\n    return browser.$('my-app');\n  }\n  get login() {\n    // app-login lives in my-app's light DOM\n    return this.app.$('app-login');\n  }\n\n  get usernameInput() {\n    // the username input is inside app-login's shadow DOM\n    return this.login.shadow$('input #username');\n  }\n\n  get passwordInput() {\n    // the password input is inside app-login's shadow DOM\n    return this.login.shadow$('input[type=password]');\n  }\n  get submitButton() {\n    // the submit button is inside app-login's shadow DOM\n    return this.login.shadow$('button[type=submit]');\n  }\n\n  login(username, password) {\n    this.login.setValue(username);\n    this.username.setValue(password);\n    this.submitButton.click();\n  }\n}\n")),(0,r.kt)("p",null,"In the example above, you can see how it's easy to leverage the getter methods of your page object to drill further and further into different parts of your application. This keeps your selectors nice and focused. For example, should you decide to move the ",(0,r.kt)("inlineCode",{parentName:"p"},"app-login")," element around, you only have to change one selector."),(0,r.kt)("h2",{id:"component-objects"},"Component Objects"),(0,r.kt)("p",null,"Following the page object pattern is really powerful on its own. The big draw of web components is that you can create reusable elements. The downside with only using page objects though, is that you might end up repeating code and selectors in different page objects to be able to interact with the elements encapsulated in your web components."),(0,r.kt)("p",null," The component object pattern attempts to reduce that repetition and move the component's api into an object of its own. We know that in order to interact with an element's shadow DOM, we first need the host element. Using a base class for your component objects makes this pretty straightforward. Here's a bare-bones component base class that takes the ",(0,r.kt)("inlineCode",{parentName:"p"},"host")," element in its constructor and unrolls that element's queries up to the browser object, so it can be reused in many page objects (or other component objects), without having to know anything about the page itself:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"class Component {\n\n  constructor(host) {\n    const selectors = [];\n    // Crawl back to the browser object, and cache all selectors\n    while (host.elementId && host.parent) {\n      selectors.push(host.selector);\n      host = host.parent;\n    }\n    selectors.reverse();\n    this.selectors_ = selectors;\n  }\n\n  get host() {\n    // Beginning with the browser object, reselect each element\n    return this.selectors_.reduce((element, selector) => element.$(selector), browser);\n  }\n}\n\nmodule.exports = Component;\n")),(0,r.kt)("p",null,"We can then write a subclass for our app-login component:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const Component = require('./component');\n\nclass Login extends Component {\n\n  get usernameInput() {\n    return this.host.shadow$('input #username');\n  }\n\n  get passwordInput() {\n    return this.host.shadow$('input[type=password]');\n  }\n\n  get submitButton() {\n    return this.login.shadow$('button[type=submit]');\n  }\n\n  login(username, password) {\n    this.usernameInput.setValue(username);\n    this.passwordInput.setValue(password);\n    this.submitButton.click();\n  }\n}\n\nmodule.exports = Login;\n")),(0,r.kt)("p",null,"Finally, we can use the component object inside our login page object:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"const Login = require('./components/login');\n\nclass LoginPage {\n\n  open() {\n    browser.url('/login');\n  }\n\n  get app() {\n    return browser.$('my-app');\n  }\n\n  get loginComponent() {\n    // return a new instance of our login component object\n    return new Login(this.app.$('app-login'));\n  }\n\n}\n")),(0,r.kt)("p",null,"This component object can now be used in tests for any page or section of your app that uses an app-login web component, without having to know about how that component is structured. If you later decide to change the internal structure of the web component, you only need to update the component object."),(0,r.kt)("h2",{id:"future"},"Future"),(0,r.kt)("p",null,"Currently the ",(0,r.kt)("a",{parentName:"p",href:"https://w3c.github.io/webdriver/"},"WebDriver protocol")," does not provide native support for shadow DOM, but there has been ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/w3c/webdriver/pull/1320"},"progress")," made for it. Once the spec is finalized, WebdriverIO will implement the spec. There's a decent chance that the ",(0,r.kt)("inlineCode",{parentName:"p"},"shadow")," commands will change under the hood, but I'm pretty confident that they're usage will be the same as it is today, and that test code that uses them will need little to no refactoring."),(0,r.kt)("h2",{id:"browser-support"},"Browser Support"),(0,r.kt)("p",null,"IE11-Edge: Shadow DOM is not supported in IE or Edge, but can be polyfilled. The shadow commands work great with the polyfills."),(0,r.kt)("p",null,"Firefox: Calling ",(0,r.kt)("inlineCode",{parentName:"p"},"setValue(value)"),' on an input field in Firefox results in an error, complaining that the input is "not reachable by keyboard". A workaround for now is to use a custom command (or method on your component object) that sets the input field\'s value via ',(0,r.kt)("inlineCode",{parentName:"p"},"browser.execute(function)"),"."),(0,r.kt)("p",null,"Safari: WebdriverIO has some safety mechanisms to help mitigate issues with stale element references. This is a really nice feature but unfortunately Safari's webdriver does not provide the proper error response when attempting to interact with what in other browsers, is a stale element reference. This is unfortunate but at the same time, it's generally a bad practice to cache element references. Stale element references are typically completely mitigated by using the page and component object patterns outlined above."),(0,r.kt)("p",null,"Chrome: it just works. \ud83c\udf89"))}d.isMDXComponent=!0}}]);