"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2927],{4137:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,d=u["".concat(l,".").concat(h)]||u[h]||m[h]||o;return n?r.createElement(d,s(s({ref:t},p),{},{components:n})):r.createElement(d,s({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7356:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return p},toc:function(){return m},default:function(){return h}});var r=n(7462),a=n(3366),o=(n(7294),n(4137)),s=["components"],i={title:"React Selectors",author:"Baruch Velez",authorURL:"http://github.com/baruchvlz",authorImageURL:"https://avatars1.githubusercontent.com/u/14321495?s=460&v=4"},l=void 0,c={permalink:"/blog/2019/04/03/react-selectors",editUrl:"https://github.com/Abhi6722/hackers-hub/edit/main/website/blog/blog/2019-04-03-react-selectors.md",source:"@site/blog/2019-04-03-react-selectors.md",title:"React Selectors",description:"ReactJS is one of the most widely use Front-End libraries in the web. Along side React, many developers use styling tools that will minify or re-write the class attribute values attached to the HTML elements via className props in JSX. These minifications and overwrites make it difficult to select the generated HTML using the WebDriver's query commands like findElement or findElements since it's not guaranteed that the class name will remain the same.",date:"2019-04-03T00:00:00.000Z",formattedDate:"April 3, 2019",tags:[],readingTime:3.695,truncated:!1,authors:[{name:"Baruch Velez",url:"http://github.com/baruchvlz",imageURL:"https://avatars1.githubusercontent.com/u/14321495?s=460&v=4"}],prevItem:{title:"Visual Regression for V5",permalink:"/blog/2019/05/18/visual-regression-for-v5"},nextItem:{title:"Shadow DOM Support & reusable component objects",permalink:"/blog/2019/02/22/shadow-dom-support"}},p={authorsImageUrls:[void 0]},m=[{value:"Usage",id:"usage",children:[],level:2},{value:"Examples",id:"examples",children:[{value:"Selecting and filtering",id:"selecting-and-filtering",children:[],level:4},{value:"What about <code>browser.react$$</code>?",id:"what-about-browserreact",children:[],level:4}],level:2},{value:"Final Words",id:"final-words",children:[],level:2}],u={toc:m};function h(e){var t=e.components,n=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react"},"ReactJS")," is one of the most widely use Front-End libraries in the web. Along side React, many developers use styling tools that will minify or re-write the class attribute values attached to the HTML elements via ",(0,o.kt)("inlineCode",{parentName:"p"},"className")," props in JSX. These minifications and overwrites make it difficult to select the generated HTML using the WebDriver's query commands like ",(0,o.kt)("inlineCode",{parentName:"p"},"findElement")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"findElements")," since it's not guaranteed that the class name will remain the same."),(0,o.kt)("p",null,"Today we introduce two new commands, ",(0,o.kt)("inlineCode",{parentName:"p"},"browser.react$")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"browser.react$$"),", to WebdriverIO's browser object that allows you to query for a single or multiple React component instances in the page with an easy to use API. These new commands will return the WebdriverIO element(s) for the query in where you will have access to the complete element commands API."),(0,o.kt)("h2",{id:"usage"},"Usage"),(0,o.kt)("p",null,"Internally, WebdriverIO uses a library called ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/baruchvlz/resq"},"resq")," to query React's VirtualDOM in order to retrieve the nodes. This library allows WebdriverIO to find any component in the VirtualDOM by the component's name and also filter this selection by state and/or props."),(0,o.kt)("p",null,"WebdriverIO's provided API, ",(0,o.kt)("inlineCode",{parentName:"p"},"browser.react$")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"browser.react$$"),", methods have three parameters. The first parameter is the selector to query, this parameter is required. The second and third parameters are optional filters, ",(0,o.kt)("inlineCode",{parentName:"p"},"props")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"state")," respectively."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const selector = 'MyComponent'\nconst propFilter = { someProp: true }\nconst stateFilter = 'this is my state'\n\nbrowser.react$(selector, {\n    props: propFilter,\n    state: stateFilter\n})\n")),(0,o.kt)("p",null,"In the examples we will cover basic usages for all three parameters."),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("p",null,"In the following examples, we will base our queries against this example React application."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"// mycomponent.jsx\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nconst MyComponent = (props) => {\n    const { name } = props;\n    const [state] = React.useState(name === 'there' ? ', how are you?' : '')\n\n    return (\n        <div>\n            Hello {name || 'World'}{state}\n        </div>\n    )\n}\n\nReactDOM.render(\n    <div>\n        <MyComponent />\n        <MyComponent name=\"Barry\"/>\n        <MyComponent name=\"WebdriverIO\"/>\n        <MyComponent name=\"there\"/>\n    </div>,\n    document.getElementById('#root'),\n)\n")),(0,o.kt)("p",null,"In this app, we have one component that renders some text depending on the property ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," passed to it."),(0,o.kt)("h4",{id:"selecting-and-filtering"},"Selecting and filtering"),(0,o.kt)("p",null,"Now, let's say we want to test that the first instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"MyComponent")," is correctly displayed in the browser. Well, with the ",(0,o.kt)("inlineCode",{parentName:"p"},"browser.react$")," command, we can select this first instance and then query against it."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// spec/mycomponent.test.js\n\ntest('it should be displayed', () => {\n    const myComponent = browser.react$('MyComponent')\n\n    expect(myComponent.isDisplayed()).toBe(true) // pass\n})\n")),(0,o.kt)("p",null,"Simple, no? But what if we want to select the component that says ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello WebdriverIO")," and verify that the text is correct? Well, we can filter our queries!"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// spec/mycomponent.test.js\n\ntest('it should correctly display \"Hello WebdriverIO\"', () => {\n    const myComponent = browser.react$('MyComponent', {\n        props: { name: 'WebdriverIO' }\n    })\n\n    expect(myComponent.getText()).toBe('Hello WebdriverIO') // pass\n})\n")),(0,o.kt)("p",null,"In React, the props will always be an object so for this filter parameter we can only pass an object to be used to filter our results."),(0,o.kt)("p",null,"You might've noticed that in our component we have a state that adds extra text if the name matches ",(0,o.kt)("inlineCode",{parentName:"p"},"there"),". We can select this component by filtering the components by their current state."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"// spec/mycomponent.test.js\n\ntest('it should correctly display \"Hello WebdriverIO\"', () => {\n    const myComponent = browser.react$('MyComponent', {\n        state: ', how are you?'\n    })\n\n    expect(myComponent.getText()).toBe('Hello there, how are you?') // pass\n})\n")),(0,o.kt)("p",null,"As you can see, for the state filter we pass the string that equals to the current state of the component, this last parameter in the function can be any of the following: string, number, boolean, array, or object. This is because all these types are valid state types for React."),(0,o.kt)("h4",{id:"what-about-browserreact"},"What about ",(0,o.kt)("inlineCode",{parentName:"h4"},"browser.react$$"),"?"),(0,o.kt)("p",null,"By now you might be wondering why we are using ",(0,o.kt)("inlineCode",{parentName:"p"},"browser.react$")," in all the examples. Well, both commands have the same parameters and work almost the same with the ",(0,o.kt)("strong",{parentName:"p"},"only difference")," being that ",(0,o.kt)("inlineCode",{parentName:"p"},"browser.react$$")," will return an array of all the WebdriverIO elements corresponding to the selector and/or filter match."),(0,o.kt)("h2",{id:"final-words"},"Final Words"),(0,o.kt)("p",null,"We are very pleased with this addition and we hope you can take full advantage of it. We suggest you use ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/facebook/react-devtools"},"React Dev Tools"),", using this tool will help you see how the components in the application are called, which props they have, and which state they are currently in. Once you know this information, using WebdriverIO's React API will be a lot easier."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("strong",{parentName:"p"},"Note:")," This blog post was updated after the v6 release to reflect changes to the command interface.")))}h.isMDXComponent=!0}}]);